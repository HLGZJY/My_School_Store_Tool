# 校园信息聚合小程序 - 云函数设计文档

> **文档版本**：v1.1
> **更新日期**：2026-02-13
> **变更说明**：用户标识体系重构，openid 作为统一用户标识

---

## 云函数概览

本文档详细描述所有云函数的功能、输入输出、内部逻辑和部署配置。

---

## 一、云函数列表

| 云函数名称 | 功能描述 | 触发方式 | 版本 |
|-----------|---------|---------|------|
| login | 用户登录 | 客户端调用 | v1.1 |
| deleteUserAccount | 注销账号 | 客户端调用 | v1.1 |
| getUserInfo | 获取用户信息 | 客户端调用 | v1.1 |
| setUserRole | 设置用户角色 | 客户端调用 | v1.1 |
| getArticles | 获取文章列表 | 客户端调用 | v1.1 |
| getArticleDetail | 获取文章详情 | 客户端调用 | - |
| searchArticles | 搜索文章 | 客户端调用 | v1.1 |
| recordRead | 记录阅读历史 | 客户端调用 | v1.1 |
| collectArticle | 收藏/取消收藏 | 客户端调用 | v1.1 |
| getCollections | 获取收藏列表 | 客户端调用 | v1.1 |
| batchUncollect | 批量取消收藏 | 客户端调用 | v1.1 |
| getReadingHistory | 获取阅读历史 | 客户端调用 | v1.1 |
| clearReadingHistory | 清空阅读历史 | 客户端调用 | v1.1 |
| getMessages | 获取消息列表 | 客户端调用 | v1.1 |
| markMessageRead | 标记消息已读 | 客户端调用 | v1.1 |
| getHotArticles | 获取热门排行 | 客户端调用 | v1.1 |
| getTagCloud | 获取标签云 | 客户端调用 | v1.1 |
| getTimeline | 获取时间轴 | 客户端调用 | v1.1 |
| getSubscribeSources | 获取订阅源列表 | 客户端调用 | v1.1 |
| getHotKeywords | 获取热门搜索词 | 客户端调用 | v1.1 |
| reportSearch | 上报搜索记录 | 客户端调用 | v1.1 |
| syncData | 数据同步 | 定时触发 | - |
| processArticle | AI处理文章 | 云函数调用 | - |
| initDatabase | 初始化数据库 | 手动调用 | - |

**说明**：
- v1.1 列表示 2026-02-12 用户标识体系重构后的云函数
- 部分未实现的云函数（如 updateUserSettings、getReviewQueue、reviewArticle、cleanupExpiredData）已移除

---

## 二、用户相关云函数

### 2.1 login

**功能**：用户微信登录，获取或创建用户信息

**版本说明（v1.1）**：
- users 表主键改为 openid
- 支持自动登录检测和会话恢复
- 返回结构包含完整 userInfo 对象

**输入参数**：
```javascript
{
    code: "微信登录code",
    userInfo: {
        nickName: "用户昵称",
        avatarUrl: "头像URL"
    }
}
```

**输出结果**：
```javascript
{
    code: 0,
    message: "登录成功",
    data: {
        userId: "用户ID",
        openid: "微信OpenID",
        token: "JWT令牌",
        isNewUser: false,
        role: null,
        hasRole: false
    }
}
```

**核心逻辑**：
```javascript
'use strict';

exports.main = async (event, context) => {
    const { code, userInfo } = event;
    const db = uniCloud.database();

    try {
        // 1. 调用微信接口获取openid
        const wxResult = await uniCloud.getOpenId({
            provider: 'weixin'
        });

        if (!wxResult.openid) {
            return {
                code: 1001,
                message: '微信登录失败'
            };
        }

        const openid = wxResult.openid;

        // 2. 查询用户是否存在
        const userResult = await db.collection('users')
            .where({ openid })
            .get();

        let userId, isNewUser = false;

        if (userResult.data.length === 0) {
            // 3. 新用户，创建用户记录
            const createResult = await db.collection('users').add({
                openid,
                nickname: userInfo.nickName,
                avatar: userInfo.avatarUrl,
                role: null,
                roleDetail: {},
                settings: {
                    fontSize: 'medium',
                    darkMode: false
                },
                stats: {
                    readCount: 0,
                    collectCount: 0,
                    searchCount: 0
                },
                subscribeSources: [],
                createTime: Date.now(),
                updateTime: Date.now(),
                lastLoginTime: Date.now()
            });

            userId = createResult.id;
            isNewUser = true;
        } else {
            // 4. 老用户，更新登录时间和用户信息
            userId = userResult.data[0]._id;
            await db.collection('users').doc(userId).update({
                nickname: userInfo.nickName,
                avatar: userInfo.avatarUrl,
                lastLoginTime: Date.now(),
                updateTime: Date.now()
            });
        }

        // 5. 生成token
        const token = generateToken(userId, openid);

        // 6. 记录登录日志
        await db.collection('operation_logs').add({
            userId,
            action: 'login',
            targetId: userId,
            target: 'user',
            createTime: Date.now()
        });

        // 7. 获取用户信息
        const userData = await db.collection('users').doc(userId).get();
        const user = userData.data;

        return {
            code: 0,
            message: '登录成功',
            data: {
                userId,
                openid,
                token,
                isNewUser,
                role: user.role,
                hasRole: !!user.role
            }
        };

    } catch (error) {
        console.error('登录失败:', error);
        return {
            code: 1000,
            message: '系统错误'
        };
    }
};

// 生成JWT令牌
function generateToken(userId, openid) {
    const payload = {
        userId,
        openid,
        exp: Date.now() + 7 * 24 * 60 * 60 * 1000  // 7天过期
    };
    // 实际使用应引入jwt库生成
    return Buffer.from(JSON.stringify(payload)).toString('base64');
}
```

---

### 2.2 getArticles

**功能**：获取文章列表，支持分类、来源、标签、时间筛选

**版本说明（v1.1）**：
- pageSize 默认 10 条
- 新增来源、标签、时间范围筛选
- 推荐算法简化为"最新发布"

**输入参数**：
```javascript
{
    openid: "用户OpenID（可选）",
    category: "notice",           // 分类筛选
    sourceId: "来源ID",           // 来源筛选（v1.1新增）
    tag: "标签",                  // 标签筛选（v1.1新增）
    startDate: 0,                // 开始时间戳（v1.1新增）
    endDate: 0,                  // 结束时间戳（v1.1新增）
    page: 1,
    pageSize: 10,                // 默认10条（v1.1调整）
    refresh: false
}
```

**核心逻辑**（v1.1实际实现）：
```javascript
'use strict';

const db = uniCloud.database();

module.exports = {
    async main(event) {
        const {
            page = 1,
            pageSize = 10,
            category = '',
            sourceId = '',
            tag = '',
            startDate = 0,
            endDate = 0
        } = event;

        try {
            // 构建查询条件
            const whereCondition = { status: 'published' };

            // 分类筛选
            if (category) whereCondition.category = category;
            // 来源筛选
            if (sourceId) whereCondition.sourceId = sourceId;
            // 标签筛选
            if (tag) whereCondition['tags.source'] = tag;
            // 时间范围筛选
            if (startDate > 0 && endDate > 0) {
                whereCondition.publishTime = db.command.and(
                    db.command.gte(startDate),
                    db.command.lte(endDate)
                );
            }

            // 查询数据库
            const res = await db.collection('articles')
                .where(whereCondition)
                .orderBy('publishTime', 'desc')
                .skip((page - 1) * pageSize)
                .limit(pageSize)
                .get();

            // 获取推荐文章（最新发布的5条）
            const recommendRes = await db.collection('articles')
                .where({ status: 'published' })
                .orderBy('publishTime', 'desc')
                .limit(5)
                .get();

            return {
                code: 0,
                message: 'success',
                data: {
                    articles: res.data,
                    recommendations: recommendRes.data.map(item => ({
                        _id: item._id,
                        title: item.title,
                        sourceName: item.sourceName,
                        publishTime: item.publishTime,
                        matchReason: '最新发布'
                    })),
                    hasMore: (page - 1) * pageSize + pageSize < total,
                    total
                }
            };
        } catch (error) {
            return { code: -1, message: '获取文章失败', data: null };
        }
    }
};
```

**版本差异（v1.1）**：
| 对比项 | v1.0 | v1.1 |
|-------|------|------|
| userId | userId | openid |
| pageSize | 15 | 10 |
| 筛选条件 | 分类+角色+订阅源 | 分类+来源+标签+时间 |
| 推荐算法 | 基于角色和历史 | 最新发布 |

        // 查询文章
        const articlesResult = await db.collection('articles')
            .where(whereCondition)
            .orderBy('publishTime', 'desc')
            .skip((page - 1) * pageSize)
            .limit(pageSize)
            .get();

        const articles = articlesResult.data;

        // 获取当前用户的收藏状态
        let collectedArticleIds = [];
        if (userId) {
            const collectionsResult = await db.collection('collections')
                .where({ userId })
                .get();
            collectedArticleIds = collectionsResult.data.map(c => c.articleId);
        }

        // 标记收藏状态
        const articlesWithStatus = articles.map(article => ({
            ...article,
            isCollected: collectedArticleIds.includes(article._id)
        }));

        // 检查是否有更多
        const totalCountResult = await db.collection('articles')
            .where(whereCondition)
            .count();
        const total = totalCountResult.total;
        const hasMore = page * pageSize < total;

        // 第一页返回智能推荐
        let recommended = [];
        if (page === 1 && user) {
            recommended = await getRecommendedArticles(user, 2);
        }

        return {
            code: 0,
            message: '成功',
            data: {
                articles: articlesWithStatus,
                hasMore,
                total
            },
            recommended
        };

    } catch (error) {
        console.error('获取文章列表失败:', error);
        return {
            code: 1000,
            message: '系统错误'
        };
    }
};

// 获取角色标签
function getRoleTag(role) {
    const roleMap = {
        'student': '本科生',
        'teacher': '教职工',
        'admin': '教职工'
    };
    return roleMap[role] || '通用';
}

// 获取推荐文章
async function getRecommendedArticles(user, limit) {
    const db = uniCloud.database();

    // 获取用户最近浏览的分类
    const recentHistory = await db.collection('reading_history')
        .where({ userId: user._id })
        .orderBy('readTime', 'desc')
        .limit(5)
        .get();

    const recentCategories = recentHistory.data
        .map(h => h.article.category)
        .filter((c, i, a) => a.indexOf(c) === i);

    const whereCondition = {
        status: 'published'
    };

    // 优先推荐用户浏览过的分类
    if (recentCategories.length > 0) {
        whereCondition.category = db.command.in(recentCategories);
    }

    // 角色筛选
    const roleTag = getRoleTag(user.role);
    whereCondition['tags.role'] = db.command.in([roleTag, '通用']);

    const recommended = await db.collection('articles')
        .where(whereCondition)
        .orderBy('publishTime', 'desc')
        .limit(limit)
        .get();

    return recommended.data;
}
```

---

## 三、数据同步云函数

### 3.1 syncData

**功能**：从配置的数据源同步数据到数据库

**触发方式**：定时触发（每小时）

**定时任务配置**：
```json
{
  "triggers": [
    {
      "name": "data-sync",
      "type": "timer",
      "config": "0 * * * * * *"
    }
  ]
}
```

**核心逻辑**：
```javascript
'use strict';

const db = uniCloud.database();

exports.main = async (event, context) => {
    const { sourceId } = event;

    try {
        // 获取数据源配置
        const whereCondition = { 'schedule.enabled': true };
        if (sourceId) {
            whereCondition._id = sourceId;
        }

        const sources = await db.collection('sources')
            .where(whereCondition)
            .get();

        const results = {
            totalSources: sources.data.length,
            successSources: 0,
            failedSources: 0,
            totalArticles: 0,
            newArticles: 0,
            updatedArticles: 0
        };

        for (const source of sources.data) {
            try {
                console.log(`开始同步数据源: ${source.name}`);

                // 根据类型获取数据
                let rawData = [];
                switch (source.type) {
                    case 'rss':
                        rawData = await fetchRSSData(source);
                        break;
                    case 'api':
                        rawData = await fetchAPIData(source);
                        break;
                    case 'website':
                        rawData = await fetchWebsiteData(source);
                        break;
                    case 'manual':
                        rawData = [];
                        break;
                    default:
                        throw new Error(`未知的数据源类型: ${source.type}`);
                }

                console.log(`从 ${source.name} 获取到 ${rawData.length} 条原始数据`);

                // 处理每条数据
                for (const item of rawData) {
                    // 检查文章是否已存在
                    const existing = await db.collection('articles')
                        .where({ originalUrl: item.url })
                        .get();

                    let articleId;

                    if (existing.data.length > 0) {
                        // 更新现有文章
                        articleId = existing.data[0]._id;
                        await db.collection('articles').doc(articleId).update({
                            title: item.title,
                            content: item.content,
                            updateTime: Date.now()
                        });
                        results.updatedArticles++;
                    } else {
                        // 创建新文章（先标记为草稿，等待AI处理）
                        const createResult = await db.collection('articles').add({
                            title: item.title,
                            content: item.content,
                            plainText: item.content.replace(/<[^>]+>/g, ''),
                            category: 'notice',  // 默认分类，AI处理后更新
                            tags: {
                                source: [...source.defaultTags.source],
                                role: [...source.defaultTags.role],
                                custom: []
                            },
                            urgency: 'low',
                            sourceId: source._id,
                            sourceName: source.name,
                            originalUrl: item.url,
                            publishTime: item.publishTime || Date.now(),
                            stats: {
                                viewCount: 0,
                                collectCount: 0,
                                shareCount: 0
                            },
                            aiProcess: {
                                processed: false,
                                confidence: 0,
                                processTime: null
                            },
                            status: 'draft',  // 待AI处理
                            createTime: Date.now(),
                            updateTime: Date.now()
                        });
                        articleId = createResult.id;
                        results.newArticles++;

                        // 调用AI处理云函数
                        await uniCloud.callFunction({
                            name: 'processArticle',
                            data: {
                                articleId,
                                rawData: item
                            }
                        });
                    }

                    results.totalArticles++;
                }

                // 更新数据源统计
                await db.collection('sources').doc(source._id).update({
                    'schedule.lastRunTime': Date.now(),
                    'stats.totalArticles': db.command.inc(rawData.length),
                    'stats.lastFetchCount': rawData.length
                });

                results.successSources++;

            } catch (error) {
                console.error(`同步数据源 ${source.name} 失败:`, error);
                results.failedSources++;

                // 记录错误
                await db.collection('sources').doc(source._id).update({
                    'stats.errorCount': db.command.inc(1),
                    'stats.lastError': error.message
                });
            }
        }

        return {
            code: 0,
            message: '同步完成',
            data: results
        };

    } catch (error) {
        console.error('数据同步失败:', error);
        return {
            code: 1000,
            message: '系统错误'
        };
    }
};

// 获取RSS数据
async function fetchRSSData(source) {
    const response = await uniCloud.httpclient.request(source.config.rss.url, {
        method: 'GET',
        dataType: 'text'
    });

    // 解析RSS（实际应使用xml2js等库）
    // 这里简化处理
    const items = parseRSSXML(response.data);

    return items.map(item => ({
        title: item.title,
        content: item.description,
        url: item.link,
        publishTime: new Date(item.pubDate).getTime()
    }));
}

// 获取API数据
async function fetchAPIData(source) {
    const response = await uniCloud.httpclient.request(source.config.api.url, {
        method: source.config.api.method,
        headers: source.config.api.headers,
        dataType: 'json'
    });

    // 根据dataPath提取数据
    const data = extractDataByPath(response.data, source.config.api.dataPath);

    return data.map(item => ({
        title: item.title,
        content: item.content,
        url: item.url,
        publishTime: new Date(item.time).getTime()
    }));
}

// 解析RSS XML
function parseRSSXML(xml) {
    // 实际应使用xml2js等库解析
    return [
        { title: '示例文章1', description: '内容', link: 'https://example.com/1', pubDate: new Date().toISOString() },
        { title: '示例文章2', description: '内容', link: 'https://example.com/2', pubDate: new Date().toISOString() }
    ];
}

// 根据路径提取数据
function extractDataByPath(data, path) {
    const keys = path.split('.');
    let result = data;
    for (const key of keys) {
        result = result[key];
    }
    return result;
}
```

---

### 3.2 processArticle

**功能**：调用AI处理文章，提取结构化信息

**输入参数**：
```javascript
{
    articleId: "文章ID",
    rawData: {
        title: "原标题",
        content: "原始内容",
        url: "原文链接"
    }
}
```

**核心逻辑**：
```javascript
'use strict';

const db = uniCloud.database();
const MOONSHOT_API_KEY = process.env.MOONSHOT_API_KEY;

exports.main = async (event, context) => {
    const { articleId, rawData } = event;

    try {
        // 1. 获取文章信息
        const articleResult = await db.collection('articles').doc(articleId).get();
        const article = articleResult.data;

        if (!article) {
            return {
                code: 3001,
                message: '文章不存在'
            };
        }

        // 2. 准备AI提示
        const prompt = buildAIPrompt(rawData);

        // 3. 调用Moonshot API
        const aiResult = await callMoonshotAPI(prompt);

        if (!aiResult.success) {
            throw new Error('AI处理失败');
        }

        const processedData = aiResult.data;

        // 4. 检查置信度
        if (processedData.confidence < 80) {
            // 进入待审核队列
            await db.collection('review_queue').add({
                articleId,
                rawData,
                aiResult: {
                    processed: true,
                    confidence: processedData.confidence,
                    extractedData: processedData,
                    processTime: Date.now()
                },
                status: 'pending',
                createTime: Date.now()
            });

            return {
                code: 0,
                message: 'AI处理完成，需要人工审核',
                data: {
                    articleId,
                    confidence: processedData.confidence,
                    needsReview: true
                }
            };
        }

        // 5. 更新文章
        await db.collection('articles').doc(articleId).update({
            title: processedData.title,
            content: processedData.content,
            plainText: processedData.content.replace(/<[^>]+>/g, ''),
            summary: processedData.summary,
            category: processedData.category,
            tags: {
                source: article.tags.source,
                role: processedData.roleTags,
                custom: processedData.tags
            },
            urgency: processedData.urgency,
            urgentTag: getUrgentTag(processedData.urgency),
            aiProcess: {
                processed: true,
                confidence: processedData.confidence,
                model: 'moonshot-v1-8k',
                processTime: Date.now()
            },
            status: 'published',
            updateTime: Date.now()
        });

        return {
            code: 0,
            message: 'AI处理完成',
            data: {
                articleId,
                confidence: processedData.confidence,
                needsReview: false,
                processedData
            }
        };

    } catch (error) {
        console.error('AI处理文章失败:', error);
        return {
            code: 4003,
            message: 'AI处理失败'
        };
    }
};

// 构建AI提示
function buildAIPrompt(rawData) {
    return {
        role: 'system',
        content: `你是一个校园信息提取助手，需要从文章中提取结构化信息。

请以JSON格式返回，包含以下字段：
- title: 文章标题（精简，不超过30字）
- content: 清理后的正文内容（保留HTML格式）
- summary: 100-200字的摘要
- publishTime: 发布时间（时间戳，从文章中提取）
- tags: 提取的标签数组（最多5个，如：考试、讲座、招新等）
- category: 一级分类（只能是：通知公告/学术动态/社团活动/生活服务）
- roleTags: 角色标签数组（只能是：本科生/研究生/教职工/通用）
- urgency: 紧急程度（只能是：high/medium/low）
- confidence: 处理置信度（0-100）

分类判断规则：
- 关于课程安排、考试、放假、毕业等 → 通知公告
- 关于讲座、会议、科研成果等 → 学术动态
- 关于社团招新、比赛、演出等 → 社团活动
- 关于后勤、图书馆、就业、心理等 → 生活服务

紧急程度判断规则：
- 需要立即关注或24小时内截止 → high
- 本周内截止或需要关注 → medium
- 一般性通知 → low`
    };
}

// 调用Moonshot API
async function callMoonshotAPI(prompt) {
    try {
        const response = await uniCloud.httpclient.request('https://api.moonshot.cn/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${MOONSHOT_API_KEY}`,
                'Content-Type': 'application/json'
            },
            data: {
                model: 'moonshot-v1-8k',
                messages: [
                    prompt,
                    {
                        role: 'user',
                        content: event.rawData.content
                    }
                ],
                temperature: 0.3,
                max_tokens: 2000
            },
            dataType: 'json'
        });

        if (response.status !== 200) {
            throw new Error(`API返回错误: ${response.status}`);
        }

        const content = response.data.choices[0].message.content;
        const processedData = JSON.parse(content);

        // 验证必需字段
        if (!processedData.title || !processedData.category || !processedData.confidence) {
            throw new Error('AI返回数据不完整');
        }

        return {
            success: true,
            data: processedData
        };

    } catch (error) {
        console.error('调用Moonshot API失败:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// 获取紧急标签文字
function getUrgentTag(urgency) {
    const tagMap = {
        'high': '置顶24小时',
        'medium': '本周截止',
        'low': ''
    };
    return tagMap[urgency] || '';
}
```

---

## 四、定时任务云函数

### 4.1 updateHotKeywords

**功能**：更新热门搜索关键词统计

**触发方式**：定时触发（每小时）

**定时任务配置**：
```json
{
  "triggers": [
    {
      "name": "update-hot-keywords",
      "type": "timer",
      "config": "0 0 * * * * *"
    }
  ]
}
```

**核心逻辑**：
```javascript
'use strict';

const db = uniCloud.database();
const $ = db.command.aggregate;

exports.main = async (event, context) => {
    try {
        // 1. 获取最近7天的搜索记录
        const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

        const keywordStats = await db.collection('search_history')
            .aggregate()
            .match({
                searchTime: $.gte(sevenDaysAgo)
            })
            .group({
                _id: '$keyword',
                count: $.sum(1)
            })
            .sort({
                count: -1
            })
            .limit(50)
            .end();

        // 2. 更新热门搜索表
        await db.collection('hot_keywords').where({
            updateTime: db.command.lt(Date.now() - 3600000)
        }).remove();

        for (const item of keywordStats.data) {
            await db.collection('hot_keywords').add({
                keyword: item._id,
                count: item.count,
                updateTime: Date.now()
            });
        }

        return {
            code: 0,
            message: '热门搜索更新完成',
            data: {
                count: keywordStats.data.length
            }
        };

    } catch (error) {
        console.error('更新热门搜索失败:', error);
        return {
            code: 1000,
            message: '系统错误'
        };
    }
};
```

---

### 4.2 cleanupExpiredData

**功能**：清理过期数据

**触发方式**：定时触发（每天凌晨3点）

**定时任务配置**：
```json
{
  "triggers": [
    {
      "name": "cleanup-expired-data",
      "type": "timer",
      "config": "0 0 0 3 * * * *"
    }
  ]
}
```

**核心逻辑**：
```javascript
'use strict';

const db = uniCloud.database();

exports.main = async (event, context) => {
    const now = Date.now();

    try {
        let deletedCount = 0;

        // 1. 清理过期消息
        const expiredMessages = await db.collection('messages')
            .where({
                expireTime: db.command.lt(now)
            })
            .count();
        await db.collection('messages')
            .where({
                expireTime: db.command.lt(now)
            })
            .remove();
        deletedCount += expiredMessages.total;

        // 2. 清理30天前的搜索历史
        const thirtyDaysAgo = now - 30 * 24 * 60 * 60 * 1000;
        const oldSearchHistory = await db.collection('search_history')
            .where({
                searchTime: db.command.lt(thirtyDaysAgo)
            })
            .count();
        await db.collection('search_history')
            .where({
                searchTime: db.command.lt(thirtyDaysAgo)
            })
            .remove();
        deletedCount += oldSearchHistory.total;

        // 3. 清理90天前的操作日志
        const ninetyDaysAgo = now - 90 * 24 * 60 * 60 * 1000;
        const oldLogs = await db.collection('operation_logs')
            .where({
                createTime: db.command.lt(ninetyDaysAgo)
            })
            .count();
        await db.collection('operation_logs')
            .where({
                createTime: db.command.lt(ninetyDaysAgo)
            })
            .remove();
        deletedCount += oldLogs.total;

        // 4. 清理已过期的订阅更新通知
        const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
        const oldSubscriptions = await db.collection('subscription_updates')
            .where({
                updateTime: db.command.lt(weekAgo)
            })
            .count();
        await db.collection('subscription_updates')
            .where({
                updateTime: db.command.lt(weekAgo)
            })
            .remove();
        deletedCount += oldSubscriptions.total;

        return {
            code: 0,
            message: '过期数据清理完成',
            data: {
                deletedCount
            }
        };

    } catch (error) {
        console.error('清理过期数据失败:', error);
        return {
            code: 1000,
            message: '系统错误'
        };
    }
};
```

---

## 五、云函数部署说明

### 5.1 环境变量配置

在云开发控制台配置以下环境变量：

| 变量名 | 说明 | 示例值 |
|-------|------|-------|
| MOONSHOT_API_KEY | Moonshot API密钥 | sk-xxx |
| JWT_SECRET | JWT密钥 | your-secret-key |

### 5.2 云函数目录结构

```
uniCloud/cloudfunctions/
├── login/
│   ├── index.js
│   └── package.json
├── getArticles/
│   ├── index.js
│   └── package.json
├── syncData/
│   ├── index.js
│   ├── package.json
│   └── cloudfunction.json    # 定时触发配置
├── processArticle/
│   ├── index.js
│   └── package.json
└── ...
```

### 5.3 package.json示例

```json
{
  "name": "getArticles",
  "version": "1.0.0",
  "description": "获取文章列表",
  "main": "index.js",
  "dependencies": {
    "xml2js": "^0.4.23"
  }
}
```

### 5.4 cloudfunction.json示例（定时触发）

```json
{
  "memorySize": 512,
  "timeout": 60,
  "triggers": [
    {
      "name": "data-sync",
      "type": "timer",
      "config": "0 0 * * * * *"
    }
  ]
}
```

---

## 六、云函数错误处理规范

所有云函数应遵循以下错误处理规范：

```javascript
'use strict';

exports.main = async (event, context) => {
    try {
        // 1. 参数验证
        if (!event.userId) {
            return {
                code: 1001,
                message: '参数错误：缺少userId'
            };
        }

        // 2. 业务逻辑
        const result = await doSomething();

        // 3. 返回结果
        return {
            code: 0,
            message: '成功',
            data: result
        };

    } catch (error) {
        console.error('云函数执行失败:', error);

        // 4. 错误分类处理
        if (error.message.includes('not found')) {
            return {
                code: 1004,
                message: '资源不存在'
            };
        }

        // 5. 默认错误响应
        return {
            code: 1000,
            message: '系统错误'
        };
    }
};
```

---

## 七、云函数性能优化建议

1. **减少数据库查询次数**：使用批量查询和聚合管道
2. **使用缓存**：对热点数据使用云缓存
3. **异步处理**：耗时操作使用异步处理
4. **分页查询**：避免一次性查询大量数据
5. **合理设置超时**：根据实际需求设置超时时间
6. **日志记录**：记录关键操作和错误信息

---

## 八、云函数监控与告警

在云开发控制台配置监控告警：

| 监控项 | 阈值 | 告警方式 |
|-------|------|---------|
| 云函数调用失败率 | > 5% | 邮件通知 |
| 云函数平均执行时间 | > 3秒 | 邮件通知 |
| 云函数调用次数（日） | > 10000 | - |
| 数据库查询耗时 | > 500ms | - |
